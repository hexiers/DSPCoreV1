/*======================================================================================================
* @文件名称	:                                                       
* @文件描述	: 	定义移动平率滤波器初始化函数和移动平均计算函数
* @创建人		:  	张宇                                                                              
* 创建日期	:   2020-03-07
* 修改记录	:
*                         
======================================================================================================*/
#include"MCSoft_Math.h"

stFir SpdFdbFir;
stFir IqFdbFir;
stFir IdFdbFir;
stFir CoreVBusFdbFir;
stFir CoreSpdFdbFir;
stFir Flux_EstSpdFdbFir;

/**************************************************************************************************************************************************
* @函数名		: FirInit
* @函数描述	: 移动平均滤波器参数初始化
* @创建人		: 张宇
* 创建日期	: 2020-03-07
* 修改记录	:
*                         
****************************************************************************************************************************************************/

void FirInit(stpFir stp,Uint16 FilterPower)
{
	Uint16 i = 0;
	//数据保护
	if(FilterPower > 7) //最大为128次滤波
		stp->Power = 7;
	else
		stp->Power = FilterPower;

	stp->FifoLen = 1<<(stp->Power);
	for(i = 0;i<stp->FifoLen;i++)
	{
		stp->Fifo[i] = 0;
	}
	stp->pCnt = 0;
	stp->Sum = 0;
}

/**************************************************************************************************************************************************
* @函数名		: FirCalc
* @函数描述	: 移动平均滤波器计算函数，DataIn为新添加的数值；EnDiv设置是否使能除法，1使能，0不能使能；返回滤波后的值
* @创建人		: 张宇
* 创建日期	: 2020-03-07
* 修改记录	:
*                         
****************************************************************************************************************************************************/

INT32S FirCalc(stpFir stp,INT32S DataIn,Uint16 EnDiv)
{
	volatile INT32S TempRtn = 0;

	stp->Fifo[stp->pCnt] = DataIn;
	stp->Sum += stp->Fifo[stp->pCnt]; //加上最新的数据

	if(EnDiv)//!!通过4个数组的推导计算可得，若按原方案，和SUM中值存三个数，因此在该位置调换顺序，先求平均，再减去老值
		TempRtn = stp->Sum >> stp->Power;
	else
		TempRtn = stp->Sum;
    //减去最旧的数据,必须放在返回之后
	stp->Sum -= stp->Fifo[(stp->pCnt + 1) & (stp->FifoLen-1)];

	stp->pCnt ++;
	if(stp->pCnt >= stp->FifoLen)
	{
		stp->pCnt = 0;
	}

	return TempRtn;
}
